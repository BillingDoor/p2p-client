// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsMessage_CommandImpl();
void InitDefaultsMessage_Command();
void InitDefaultsMessage_ResponseImpl();
void InitDefaultsMessage_Response();
void InitDefaultsMessage_FileChunkImpl();
void InitDefaultsMessage_FileChunk();
void InitDefaultsMessage_NATRequestImpl();
void InitDefaultsMessage_NATRequest();
void InitDefaultsMessage_NATCheckImpl();
void InitDefaultsMessage_NATCheck();
void InitDefaultsMessage_JoinImpl();
void InitDefaultsMessage_Join();
void InitDefaultsMessage_LeaveImpl();
void InitDefaultsMessage_Leave();
void InitDefaultsMessageImpl();
void InitDefaultsMessage();
inline void InitDefaults() {
  InitDefaultsMessage_Command();
  InitDefaultsMessage_Response();
  InitDefaultsMessage_FileChunk();
  InitDefaultsMessage_NATRequest();
  InitDefaultsMessage_NATCheck();
  InitDefaultsMessage_Join();
  InitDefaultsMessage_Leave();
  InitDefaultsMessage();
}
}  // namespace protobuf_Message_2eproto
namespace botnet_p2p {
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Message_Command;
class Message_CommandDefaultTypeInternal;
extern Message_CommandDefaultTypeInternal _Message_Command_default_instance_;
class Message_FileChunk;
class Message_FileChunkDefaultTypeInternal;
extern Message_FileChunkDefaultTypeInternal _Message_FileChunk_default_instance_;
class Message_Join;
class Message_JoinDefaultTypeInternal;
extern Message_JoinDefaultTypeInternal _Message_Join_default_instance_;
class Message_Leave;
class Message_LeaveDefaultTypeInternal;
extern Message_LeaveDefaultTypeInternal _Message_Leave_default_instance_;
class Message_NATCheck;
class Message_NATCheckDefaultTypeInternal;
extern Message_NATCheckDefaultTypeInternal _Message_NATCheck_default_instance_;
class Message_NATRequest;
class Message_NATRequestDefaultTypeInternal;
extern Message_NATRequestDefaultTypeInternal _Message_NATRequest_default_instance_;
class Message_Response;
class Message_ResponseDefaultTypeInternal;
extern Message_ResponseDefaultTypeInternal _Message_Response_default_instance_;
}  // namespace botnet_p2p
namespace botnet_p2p {

enum Message_MessageType {
  Message_MessageType_UNDEFINED = 0,
  Message_MessageType_COMMAND = 1,
  Message_MessageType_RESPONSE = 2,
  Message_MessageType_FILE_CHUNK = 3,
  Message_MessageType_NAT_REQUEST = 4,
  Message_MessageType_NAT_CHECK = 5,
  Message_MessageType_PING = 6,
  Message_MessageType_JOIN = 7,
  Message_MessageType_LEAVE = 8,
  Message_MessageType_Message_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Message_MessageType_Message_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Message_MessageType_IsValid(int value);
const Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_UNDEFINED;
const Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_LEAVE;
const int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_MessageType_descriptor();
inline const ::std::string& Message_MessageType_Name(Message_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_MessageType_descriptor(), value);
}
inline bool Message_MessageType_Parse(
    const ::std::string& name, Message_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_MessageType>(
    Message_MessageType_descriptor(), name, value);
}
enum Message_Status {
  Message_Status_FAIL = 0,
  Message_Status_OK = 1,
  Message_Status_Message_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Message_Status_Message_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Message_Status_IsValid(int value);
const Message_Status Message_Status_Status_MIN = Message_Status_FAIL;
const Message_Status Message_Status_Status_MAX = Message_Status_OK;
const int Message_Status_Status_ARRAYSIZE = Message_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Status_descriptor();
inline const ::std::string& Message_Status_Name(Message_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Status_descriptor(), value);
}
inline bool Message_Status_Parse(
    const ::std::string& name, Message_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Status>(
    Message_Status_descriptor(), name, value);
}
// ===================================================================

class Message_Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message.Command) */ {
 public:
  Message_Command();
  virtual ~Message_Command();

  Message_Command(const Message_Command& from);

  inline Message_Command& operator=(const Message_Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message_Command(Message_Command&& from) noexcept
    : Message_Command() {
    *this = ::std::move(from);
  }

  inline Message_Command& operator=(Message_Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message_Command* internal_default_instance() {
    return reinterpret_cast<const Message_Command*>(
               &_Message_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Message_Command* other);
  friend void swap(Message_Command& a, Message_Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message_Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Message_Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message_Command& from);
  void MergeFrom(const Message_Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message_Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string commandString = 1;
  void clear_commandstring();
  static const int kCommandStringFieldNumber = 1;
  const ::std::string& commandstring() const;
  void set_commandstring(const ::std::string& value);
  #if LANG_CXX11
  void set_commandstring(::std::string&& value);
  #endif
  void set_commandstring(const char* value);
  void set_commandstring(const char* value, size_t size);
  ::std::string* mutable_commandstring();
  ::std::string* release_commandstring();
  void set_allocated_commandstring(::std::string* commandstring);

  // bool sendResponse = 2;
  void clear_sendresponse();
  static const int kSendResponseFieldNumber = 2;
  bool sendresponse() const;
  void set_sendresponse(bool value);

  // @@protoc_insertion_point(class_scope:botnet_p2p.Message.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr commandstring_;
  bool sendresponse_;
  mutable int _cached_size_;
  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessage_CommandImpl();
};
// -------------------------------------------------------------------

class Message_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message.Response) */ {
 public:
  Message_Response();
  virtual ~Message_Response();

  Message_Response(const Message_Response& from);

  inline Message_Response& operator=(const Message_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message_Response(Message_Response&& from) noexcept
    : Message_Response() {
    *this = ::std::move(from);
  }

  inline Message_Response& operator=(Message_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message_Response* internal_default_instance() {
    return reinterpret_cast<const Message_Response*>(
               &_Message_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Message_Response* other);
  friend void swap(Message_Response& a, Message_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message_Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Message_Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message_Response& from);
  void MergeFrom(const Message_Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .botnet_p2p.Message.Status status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::botnet_p2p::Message_Status status() const;
  void set_status(::botnet_p2p::Message_Status value);

  // @@protoc_insertion_point(class_scope:botnet_p2p.Message.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessage_ResponseImpl();
};
// -------------------------------------------------------------------

class Message_FileChunk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message.FileChunk) */ {
 public:
  Message_FileChunk();
  virtual ~Message_FileChunk();

  Message_FileChunk(const Message_FileChunk& from);

  inline Message_FileChunk& operator=(const Message_FileChunk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message_FileChunk(Message_FileChunk&& from) noexcept
    : Message_FileChunk() {
    *this = ::std::move(from);
  }

  inline Message_FileChunk& operator=(Message_FileChunk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_FileChunk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message_FileChunk* internal_default_instance() {
    return reinterpret_cast<const Message_FileChunk*>(
               &_Message_FileChunk_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Message_FileChunk* other);
  friend void swap(Message_FileChunk& a, Message_FileChunk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message_FileChunk* New() const PROTOBUF_FINAL { return New(NULL); }

  Message_FileChunk* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message_FileChunk& from);
  void MergeFrom(const Message_FileChunk& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message_FileChunk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // bytes data = 6;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // bool name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  bool name() const;
  void set_name(bool value);

  // uint32 chunkNumber = 3;
  void clear_chunknumber();
  static const int kChunkNumberFieldNumber = 3;
  ::google::protobuf::uint32 chunknumber() const;
  void set_chunknumber(::google::protobuf::uint32 value);

  // uint32 allChunks = 4;
  void clear_allchunks();
  static const int kAllChunksFieldNumber = 4;
  ::google::protobuf::uint32 allchunks() const;
  void set_allchunks(::google::protobuf::uint32 value);

  // uint32 chunkSize = 5;
  void clear_chunksize();
  static const int kChunkSizeFieldNumber = 5;
  ::google::protobuf::uint32 chunksize() const;
  void set_chunksize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:botnet_p2p.Message.FileChunk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  bool name_;
  ::google::protobuf::uint32 chunknumber_;
  ::google::protobuf::uint32 allchunks_;
  ::google::protobuf::uint32 chunksize_;
  mutable int _cached_size_;
  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessage_FileChunkImpl();
};
// -------------------------------------------------------------------

class Message_NATRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message.NATRequest) */ {
 public:
  Message_NATRequest();
  virtual ~Message_NATRequest();

  Message_NATRequest(const Message_NATRequest& from);

  inline Message_NATRequest& operator=(const Message_NATRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message_NATRequest(Message_NATRequest&& from) noexcept
    : Message_NATRequest() {
    *this = ::std::move(from);
  }

  inline Message_NATRequest& operator=(Message_NATRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_NATRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message_NATRequest* internal_default_instance() {
    return reinterpret_cast<const Message_NATRequest*>(
               &_Message_NATRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Message_NATRequest* other);
  friend void swap(Message_NATRequest& a, Message_NATRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message_NATRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  Message_NATRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message_NATRequest& from);
  void MergeFrom(const Message_NATRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message_NATRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // @@protoc_insertion_point(class_scope:botnet_p2p.Message.NATRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  mutable int _cached_size_;
  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessage_NATRequestImpl();
};
// -------------------------------------------------------------------

class Message_NATCheck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message.NATCheck) */ {
 public:
  Message_NATCheck();
  virtual ~Message_NATCheck();

  Message_NATCheck(const Message_NATCheck& from);

  inline Message_NATCheck& operator=(const Message_NATCheck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message_NATCheck(Message_NATCheck&& from) noexcept
    : Message_NATCheck() {
    *this = ::std::move(from);
  }

  inline Message_NATCheck& operator=(Message_NATCheck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_NATCheck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message_NATCheck* internal_default_instance() {
    return reinterpret_cast<const Message_NATCheck*>(
               &_Message_NATCheck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Message_NATCheck* other);
  friend void swap(Message_NATCheck& a, Message_NATCheck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message_NATCheck* New() const PROTOBUF_FINAL { return New(NULL); }

  Message_NATCheck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message_NATCheck& from);
  void MergeFrom(const Message_NATCheck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message_NATCheck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string source = 1;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // @@protoc_insertion_point(class_scope:botnet_p2p.Message.NATCheck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  mutable int _cached_size_;
  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessage_NATCheckImpl();
};
// -------------------------------------------------------------------

class Message_Join : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message.Join) */ {
 public:
  Message_Join();
  virtual ~Message_Join();

  Message_Join(const Message_Join& from);

  inline Message_Join& operator=(const Message_Join& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message_Join(Message_Join&& from) noexcept
    : Message_Join() {
    *this = ::std::move(from);
  }

  inline Message_Join& operator=(Message_Join&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Join& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message_Join* internal_default_instance() {
    return reinterpret_cast<const Message_Join*>(
               &_Message_Join_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Message_Join* other);
  friend void swap(Message_Join& a, Message_Join& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message_Join* New() const PROTOBUF_FINAL { return New(NULL); }

  Message_Join* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message_Join& from);
  void MergeFrom(const Message_Join& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message_Join* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string IP = 1;
  void clear_ip();
  static const int kIPFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string Port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // bool isNAT = 3;
  void clear_isnat();
  static const int kIsNATFieldNumber = 3;
  bool isnat() const;
  void set_isnat(bool value);

  // @@protoc_insertion_point(class_scope:botnet_p2p.Message.Join)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  bool isnat_;
  mutable int _cached_size_;
  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessage_JoinImpl();
};
// -------------------------------------------------------------------

class Message_Leave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message.Leave) */ {
 public:
  Message_Leave();
  virtual ~Message_Leave();

  Message_Leave(const Message_Leave& from);

  inline Message_Leave& operator=(const Message_Leave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message_Leave(Message_Leave&& from) noexcept
    : Message_Leave() {
    *this = ::std::move(from);
  }

  inline Message_Leave& operator=(Message_Leave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Leave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message_Leave* internal_default_instance() {
    return reinterpret_cast<const Message_Leave*>(
               &_Message_Leave_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Message_Leave* other);
  friend void swap(Message_Leave& a, Message_Leave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message_Leave* New() const PROTOBUF_FINAL { return New(NULL); }

  Message_Leave* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message_Leave& from);
  void MergeFrom(const Message_Leave& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message_Leave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string guid = 1;
  void clear_guid();
  static const int kGuidFieldNumber = 1;
  const ::std::string& guid() const;
  void set_guid(const ::std::string& value);
  #if LANG_CXX11
  void set_guid(::std::string&& value);
  #endif
  void set_guid(const char* value);
  void set_guid(const char* value, size_t size);
  ::std::string* mutable_guid();
  ::std::string* release_guid();
  void set_allocated_guid(::std::string* guid);

  // @@protoc_insertion_point(class_scope:botnet_p2p.Message.Leave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr guid_;
  mutable int _cached_size_;
  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessage_LeaveImpl();
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:botnet_p2p.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum PayloadCase {
    kPCommand = 7,
    kPResponse = 8,
    kPFile = 9,
    kPNATRequest = 10,
    kPNATCheck = 11,
    kPJoin = 12,
    kPLeave = 13,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Message_Command Command;
  typedef Message_Response Response;
  typedef Message_FileChunk FileChunk;
  typedef Message_NATRequest NATRequest;
  typedef Message_NATCheck NATCheck;
  typedef Message_Join Join;
  typedef Message_Leave Leave;

  typedef Message_MessageType MessageType;
  static const MessageType UNDEFINED =
    Message_MessageType_UNDEFINED;
  static const MessageType COMMAND =
    Message_MessageType_COMMAND;
  static const MessageType RESPONSE =
    Message_MessageType_RESPONSE;
  static const MessageType FILE_CHUNK =
    Message_MessageType_FILE_CHUNK;
  static const MessageType NAT_REQUEST =
    Message_MessageType_NAT_REQUEST;
  static const MessageType NAT_CHECK =
    Message_MessageType_NAT_CHECK;
  static const MessageType PING =
    Message_MessageType_PING;
  static const MessageType JOIN =
    Message_MessageType_JOIN;
  static const MessageType LEAVE =
    Message_MessageType_LEAVE;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Message_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Message_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Message_MessageType_Parse(name, value);
  }

  typedef Message_Status Status;
  static const Status FAIL =
    Message_Status_FAIL;
  static const Status OK =
    Message_Status_OK;
  static inline bool Status_IsValid(int value) {
    return Message_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Message_Status_Status_MIN;
  static const Status Status_MAX =
    Message_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Message_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Message_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Message_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Message_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string sender = 3;
  void clear_sender();
  static const int kSenderFieldNumber = 3;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // string receiver = 4;
  void clear_receiver();
  static const int kReceiverFieldNumber = 4;
  const ::std::string& receiver() const;
  void set_receiver(const ::std::string& value);
  #if LANG_CXX11
  void set_receiver(::std::string&& value);
  #endif
  void set_receiver(const char* value);
  void set_receiver(const char* value, size_t size);
  ::std::string* mutable_receiver();
  ::std::string* release_receiver();
  void set_allocated_receiver(::std::string* receiver);

  // bytes signature = 6;
  void clear_signature();
  static const int kSignatureFieldNumber = 6;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // .botnet_p2p.Message.MessageType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::botnet_p2p::Message_MessageType type() const;
  void set_type(::botnet_p2p::Message_MessageType value);

  // bool propagation = 5;
  void clear_propagation();
  static const int kPropagationFieldNumber = 5;
  bool propagation() const;
  void set_propagation(bool value);

  // .botnet_p2p.Message.Command pCommand = 7;
  bool has_pcommand() const;
  void clear_pcommand();
  static const int kPCommandFieldNumber = 7;
  const ::botnet_p2p::Message_Command& pcommand() const;
  ::botnet_p2p::Message_Command* release_pcommand();
  ::botnet_p2p::Message_Command* mutable_pcommand();
  void set_allocated_pcommand(::botnet_p2p::Message_Command* pcommand);

  // .botnet_p2p.Message.Response pResponse = 8;
  bool has_presponse() const;
  void clear_presponse();
  static const int kPResponseFieldNumber = 8;
  const ::botnet_p2p::Message_Response& presponse() const;
  ::botnet_p2p::Message_Response* release_presponse();
  ::botnet_p2p::Message_Response* mutable_presponse();
  void set_allocated_presponse(::botnet_p2p::Message_Response* presponse);

  // .botnet_p2p.Message.FileChunk pFile = 9;
  bool has_pfile() const;
  void clear_pfile();
  static const int kPFileFieldNumber = 9;
  const ::botnet_p2p::Message_FileChunk& pfile() const;
  ::botnet_p2p::Message_FileChunk* release_pfile();
  ::botnet_p2p::Message_FileChunk* mutable_pfile();
  void set_allocated_pfile(::botnet_p2p::Message_FileChunk* pfile);

  // .botnet_p2p.Message.NATRequest pNATRequest = 10;
  bool has_pnatrequest() const;
  void clear_pnatrequest();
  static const int kPNATRequestFieldNumber = 10;
  const ::botnet_p2p::Message_NATRequest& pnatrequest() const;
  ::botnet_p2p::Message_NATRequest* release_pnatrequest();
  ::botnet_p2p::Message_NATRequest* mutable_pnatrequest();
  void set_allocated_pnatrequest(::botnet_p2p::Message_NATRequest* pnatrequest);

  // .botnet_p2p.Message.NATCheck pNATCheck = 11;
  bool has_pnatcheck() const;
  void clear_pnatcheck();
  static const int kPNATCheckFieldNumber = 11;
  const ::botnet_p2p::Message_NATCheck& pnatcheck() const;
  ::botnet_p2p::Message_NATCheck* release_pnatcheck();
  ::botnet_p2p::Message_NATCheck* mutable_pnatcheck();
  void set_allocated_pnatcheck(::botnet_p2p::Message_NATCheck* pnatcheck);

  // .botnet_p2p.Message.Join pJoin = 12;
  bool has_pjoin() const;
  void clear_pjoin();
  static const int kPJoinFieldNumber = 12;
  const ::botnet_p2p::Message_Join& pjoin() const;
  ::botnet_p2p::Message_Join* release_pjoin();
  ::botnet_p2p::Message_Join* mutable_pjoin();
  void set_allocated_pjoin(::botnet_p2p::Message_Join* pjoin);

  // .botnet_p2p.Message.Leave pLeave = 13;
  bool has_pleave() const;
  void clear_pleave();
  static const int kPLeaveFieldNumber = 13;
  const ::botnet_p2p::Message_Leave& pleave() const;
  ::botnet_p2p::Message_Leave* release_pleave();
  ::botnet_p2p::Message_Leave* mutable_pleave();
  void set_allocated_pleave(::botnet_p2p::Message_Leave* pleave);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:botnet_p2p.Message)
 private:
  void set_has_pcommand();
  void set_has_presponse();
  void set_has_pfile();
  void set_has_pnatrequest();
  void set_has_pnatcheck();
  void set_has_pjoin();
  void set_has_pleave();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  ::google::protobuf::internal::ArenaStringPtr receiver_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  int type_;
  bool propagation_;
  union PayloadUnion {
    PayloadUnion() {}
    ::botnet_p2p::Message_Command* pcommand_;
    ::botnet_p2p::Message_Response* presponse_;
    ::botnet_p2p::Message_FileChunk* pfile_;
    ::botnet_p2p::Message_NATRequest* pnatrequest_;
    ::botnet_p2p::Message_NATCheck* pnatcheck_;
    ::botnet_p2p::Message_Join* pjoin_;
    ::botnet_p2p::Message_Leave* pleave_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Message_2eproto::TableStruct;
  friend void ::protobuf_Message_2eproto::InitDefaultsMessageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message_Command

// string commandString = 1;
inline void Message_Command::clear_commandstring() {
  commandstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_Command::commandstring() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Command.commandString)
  return commandstring_.GetNoArena();
}
inline void Message_Command::set_commandstring(const ::std::string& value) {
  
  commandstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Command.commandString)
}
#if LANG_CXX11
inline void Message_Command::set_commandstring(::std::string&& value) {
  
  commandstring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.Command.commandString)
}
#endif
inline void Message_Command::set_commandstring(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  commandstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.Command.commandString)
}
inline void Message_Command::set_commandstring(const char* value, size_t size) {
  
  commandstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.Command.commandString)
}
inline ::std::string* Message_Command::mutable_commandstring() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.Command.commandString)
  return commandstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_Command::release_commandstring() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.Command.commandString)
  
  return commandstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_Command::set_allocated_commandstring(::std::string* commandstring) {
  if (commandstring != NULL) {
    
  } else {
    
  }
  commandstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commandstring);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.Command.commandString)
}

// bool sendResponse = 2;
inline void Message_Command::clear_sendresponse() {
  sendresponse_ = false;
}
inline bool Message_Command::sendresponse() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Command.sendResponse)
  return sendresponse_;
}
inline void Message_Command::set_sendresponse(bool value) {
  
  sendresponse_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Command.sendResponse)
}

// -------------------------------------------------------------------

// Message_Response

// string value = 1;
inline void Message_Response::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_Response::value() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Response.value)
  return value_.GetNoArena();
}
inline void Message_Response::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Response.value)
}
#if LANG_CXX11
inline void Message_Response::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.Response.value)
}
#endif
inline void Message_Response::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.Response.value)
}
inline void Message_Response::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.Response.value)
}
inline ::std::string* Message_Response::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.Response.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_Response::release_value() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.Response.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_Response::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.Response.value)
}

// .botnet_p2p.Message.Status status = 2;
inline void Message_Response::clear_status() {
  status_ = 0;
}
inline ::botnet_p2p::Message_Status Message_Response::status() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Response.status)
  return static_cast< ::botnet_p2p::Message_Status >(status_);
}
inline void Message_Response::set_status(::botnet_p2p::Message_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Response.status)
}

// -------------------------------------------------------------------

// Message_FileChunk

// string path = 1;
inline void Message_FileChunk::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_FileChunk::path() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.FileChunk.path)
  return path_.GetNoArena();
}
inline void Message_FileChunk::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.FileChunk.path)
}
#if LANG_CXX11
inline void Message_FileChunk::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.FileChunk.path)
}
#endif
inline void Message_FileChunk::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.FileChunk.path)
}
inline void Message_FileChunk::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.FileChunk.path)
}
inline ::std::string* Message_FileChunk::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.FileChunk.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_FileChunk::release_path() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.FileChunk.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_FileChunk::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.FileChunk.path)
}

// bool name = 2;
inline void Message_FileChunk::clear_name() {
  name_ = false;
}
inline bool Message_FileChunk::name() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.FileChunk.name)
  return name_;
}
inline void Message_FileChunk::set_name(bool value) {
  
  name_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.FileChunk.name)
}

// uint32 chunkNumber = 3;
inline void Message_FileChunk::clear_chunknumber() {
  chunknumber_ = 0u;
}
inline ::google::protobuf::uint32 Message_FileChunk::chunknumber() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.FileChunk.chunkNumber)
  return chunknumber_;
}
inline void Message_FileChunk::set_chunknumber(::google::protobuf::uint32 value) {
  
  chunknumber_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.FileChunk.chunkNumber)
}

// uint32 allChunks = 4;
inline void Message_FileChunk::clear_allchunks() {
  allchunks_ = 0u;
}
inline ::google::protobuf::uint32 Message_FileChunk::allchunks() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.FileChunk.allChunks)
  return allchunks_;
}
inline void Message_FileChunk::set_allchunks(::google::protobuf::uint32 value) {
  
  allchunks_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.FileChunk.allChunks)
}

// uint32 chunkSize = 5;
inline void Message_FileChunk::clear_chunksize() {
  chunksize_ = 0u;
}
inline ::google::protobuf::uint32 Message_FileChunk::chunksize() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.FileChunk.chunkSize)
  return chunksize_;
}
inline void Message_FileChunk::set_chunksize(::google::protobuf::uint32 value) {
  
  chunksize_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.FileChunk.chunkSize)
}

// bytes data = 6;
inline void Message_FileChunk::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_FileChunk::data() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.FileChunk.data)
  return data_.GetNoArena();
}
inline void Message_FileChunk::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.FileChunk.data)
}
#if LANG_CXX11
inline void Message_FileChunk::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.FileChunk.data)
}
#endif
inline void Message_FileChunk::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.FileChunk.data)
}
inline void Message_FileChunk::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.FileChunk.data)
}
inline ::std::string* Message_FileChunk::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.FileChunk.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_FileChunk::release_data() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.FileChunk.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_FileChunk::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.FileChunk.data)
}

// -------------------------------------------------------------------

// Message_NATRequest

// string target = 1;
inline void Message_NATRequest::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_NATRequest::target() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.NATRequest.target)
  return target_.GetNoArena();
}
inline void Message_NATRequest::set_target(const ::std::string& value) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.NATRequest.target)
}
#if LANG_CXX11
inline void Message_NATRequest::set_target(::std::string&& value) {
  
  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.NATRequest.target)
}
#endif
inline void Message_NATRequest::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.NATRequest.target)
}
inline void Message_NATRequest::set_target(const char* value, size_t size) {
  
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.NATRequest.target)
}
inline ::std::string* Message_NATRequest::mutable_target() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.NATRequest.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_NATRequest::release_target() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.NATRequest.target)
  
  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_NATRequest::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    
  } else {
    
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.NATRequest.target)
}

// -------------------------------------------------------------------

// Message_NATCheck

// string source = 1;
inline void Message_NATCheck::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_NATCheck::source() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.NATCheck.source)
  return source_.GetNoArena();
}
inline void Message_NATCheck::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.NATCheck.source)
}
#if LANG_CXX11
inline void Message_NATCheck::set_source(::std::string&& value) {
  
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.NATCheck.source)
}
#endif
inline void Message_NATCheck::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.NATCheck.source)
}
inline void Message_NATCheck::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.NATCheck.source)
}
inline ::std::string* Message_NATCheck::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.NATCheck.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_NATCheck::release_source() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.NATCheck.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_NATCheck::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.NATCheck.source)
}

// -------------------------------------------------------------------

// Message_Join

// string IP = 1;
inline void Message_Join::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_Join::ip() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Join.IP)
  return ip_.GetNoArena();
}
inline void Message_Join::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Join.IP)
}
#if LANG_CXX11
inline void Message_Join::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.Join.IP)
}
#endif
inline void Message_Join::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.Join.IP)
}
inline void Message_Join::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.Join.IP)
}
inline ::std::string* Message_Join::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.Join.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_Join::release_ip() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.Join.IP)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_Join::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.Join.IP)
}

// string Port = 2;
inline void Message_Join::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_Join::port() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Join.Port)
  return port_.GetNoArena();
}
inline void Message_Join::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Join.Port)
}
#if LANG_CXX11
inline void Message_Join::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.Join.Port)
}
#endif
inline void Message_Join::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.Join.Port)
}
inline void Message_Join::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.Join.Port)
}
inline ::std::string* Message_Join::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.Join.Port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_Join::release_port() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.Join.Port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_Join::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.Join.Port)
}

// bool isNAT = 3;
inline void Message_Join::clear_isnat() {
  isnat_ = false;
}
inline bool Message_Join::isnat() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Join.isNAT)
  return isnat_;
}
inline void Message_Join::set_isnat(bool value) {
  
  isnat_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Join.isNAT)
}

// -------------------------------------------------------------------

// Message_Leave

// string guid = 1;
inline void Message_Leave::clear_guid() {
  guid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message_Leave::guid() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.Leave.guid)
  return guid_.GetNoArena();
}
inline void Message_Leave::set_guid(const ::std::string& value) {
  
  guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.Leave.guid)
}
#if LANG_CXX11
inline void Message_Leave::set_guid(::std::string&& value) {
  
  guid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.Leave.guid)
}
#endif
inline void Message_Leave::set_guid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.Leave.guid)
}
inline void Message_Leave::set_guid(const char* value, size_t size) {
  
  guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.Leave.guid)
}
inline ::std::string* Message_Leave::mutable_guid() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.Leave.guid)
  return guid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message_Leave::release_guid() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.Leave.guid)
  
  return guid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message_Leave::set_allocated_guid(::std::string* guid) {
  if (guid != NULL) {
    
  } else {
    
  }
  guid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), guid);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.Leave.guid)
}

// -------------------------------------------------------------------

// Message

// string uuid = 1;
inline void Message::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::uuid() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.uuid)
  return uuid_.GetNoArena();
}
inline void Message::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.uuid)
}
#if LANG_CXX11
inline void Message::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.uuid)
}
#endif
inline void Message::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.uuid)
}
inline void Message::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.uuid)
}
inline ::std::string* Message::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_uuid() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.uuid)
}

// .botnet_p2p.Message.MessageType type = 2;
inline void Message::clear_type() {
  type_ = 0;
}
inline ::botnet_p2p::Message_MessageType Message::type() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.type)
  return static_cast< ::botnet_p2p::Message_MessageType >(type_);
}
inline void Message::set_type(::botnet_p2p::Message_MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.type)
}

// string sender = 3;
inline void Message::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::sender() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.sender)
  return sender_.GetNoArena();
}
inline void Message::set_sender(const ::std::string& value) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.sender)
}
#if LANG_CXX11
inline void Message::set_sender(::std::string&& value) {
  
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.sender)
}
#endif
inline void Message::set_sender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.sender)
}
inline void Message::set_sender(const char* value, size_t size) {
  
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.sender)
}
inline ::std::string* Message::mutable_sender() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_sender() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.sender)
  
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    
  } else {
    
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.sender)
}

// string receiver = 4;
inline void Message::clear_receiver() {
  receiver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::receiver() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.receiver)
  return receiver_.GetNoArena();
}
inline void Message::set_receiver(const ::std::string& value) {
  
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.receiver)
}
#if LANG_CXX11
inline void Message::set_receiver(::std::string&& value) {
  
  receiver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.receiver)
}
#endif
inline void Message::set_receiver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.receiver)
}
inline void Message::set_receiver(const char* value, size_t size) {
  
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.receiver)
}
inline ::std::string* Message::mutable_receiver() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.receiver)
  return receiver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_receiver() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.receiver)
  
  return receiver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_receiver(::std::string* receiver) {
  if (receiver != NULL) {
    
  } else {
    
  }
  receiver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.receiver)
}

// bool propagation = 5;
inline void Message::clear_propagation() {
  propagation_ = false;
}
inline bool Message::propagation() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.propagation)
  return propagation_;
}
inline void Message::set_propagation(bool value) {
  
  propagation_ = value;
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.propagation)
}

// bytes signature = 6;
inline void Message::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::signature() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.signature)
  return signature_.GetNoArena();
}
inline void Message::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:botnet_p2p.Message.signature)
}
#if LANG_CXX11
inline void Message::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:botnet_p2p.Message.signature)
}
#endif
inline void Message::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:botnet_p2p.Message.signature)
}
inline void Message::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:botnet_p2p.Message.signature)
}
inline ::std::string* Message::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_signature() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:botnet_p2p.Message.signature)
}

// .botnet_p2p.Message.Command pCommand = 7;
inline bool Message::has_pcommand() const {
  return payload_case() == kPCommand;
}
inline void Message::set_has_pcommand() {
  _oneof_case_[0] = kPCommand;
}
inline void Message::clear_pcommand() {
  if (has_pcommand()) {
    delete payload_.pcommand_;
    clear_has_payload();
  }
}
inline ::botnet_p2p::Message_Command* Message::release_pcommand() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.pCommand)
  if (has_pcommand()) {
    clear_has_payload();
      ::botnet_p2p::Message_Command* temp = payload_.pcommand_;
    payload_.pcommand_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::botnet_p2p::Message_Command& Message::pcommand() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.pCommand)
  return has_pcommand()
      ? *payload_.pcommand_
      : *reinterpret_cast< ::botnet_p2p::Message_Command*>(&::botnet_p2p::_Message_Command_default_instance_);
}
inline ::botnet_p2p::Message_Command* Message::mutable_pcommand() {
  if (!has_pcommand()) {
    clear_payload();
    set_has_pcommand();
    payload_.pcommand_ = new ::botnet_p2p::Message_Command;
  }
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.pCommand)
  return payload_.pcommand_;
}

// .botnet_p2p.Message.Response pResponse = 8;
inline bool Message::has_presponse() const {
  return payload_case() == kPResponse;
}
inline void Message::set_has_presponse() {
  _oneof_case_[0] = kPResponse;
}
inline void Message::clear_presponse() {
  if (has_presponse()) {
    delete payload_.presponse_;
    clear_has_payload();
  }
}
inline ::botnet_p2p::Message_Response* Message::release_presponse() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.pResponse)
  if (has_presponse()) {
    clear_has_payload();
      ::botnet_p2p::Message_Response* temp = payload_.presponse_;
    payload_.presponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::botnet_p2p::Message_Response& Message::presponse() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.pResponse)
  return has_presponse()
      ? *payload_.presponse_
      : *reinterpret_cast< ::botnet_p2p::Message_Response*>(&::botnet_p2p::_Message_Response_default_instance_);
}
inline ::botnet_p2p::Message_Response* Message::mutable_presponse() {
  if (!has_presponse()) {
    clear_payload();
    set_has_presponse();
    payload_.presponse_ = new ::botnet_p2p::Message_Response;
  }
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.pResponse)
  return payload_.presponse_;
}

// .botnet_p2p.Message.FileChunk pFile = 9;
inline bool Message::has_pfile() const {
  return payload_case() == kPFile;
}
inline void Message::set_has_pfile() {
  _oneof_case_[0] = kPFile;
}
inline void Message::clear_pfile() {
  if (has_pfile()) {
    delete payload_.pfile_;
    clear_has_payload();
  }
}
inline ::botnet_p2p::Message_FileChunk* Message::release_pfile() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.pFile)
  if (has_pfile()) {
    clear_has_payload();
      ::botnet_p2p::Message_FileChunk* temp = payload_.pfile_;
    payload_.pfile_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::botnet_p2p::Message_FileChunk& Message::pfile() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.pFile)
  return has_pfile()
      ? *payload_.pfile_
      : *reinterpret_cast< ::botnet_p2p::Message_FileChunk*>(&::botnet_p2p::_Message_FileChunk_default_instance_);
}
inline ::botnet_p2p::Message_FileChunk* Message::mutable_pfile() {
  if (!has_pfile()) {
    clear_payload();
    set_has_pfile();
    payload_.pfile_ = new ::botnet_p2p::Message_FileChunk;
  }
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.pFile)
  return payload_.pfile_;
}

// .botnet_p2p.Message.NATRequest pNATRequest = 10;
inline bool Message::has_pnatrequest() const {
  return payload_case() == kPNATRequest;
}
inline void Message::set_has_pnatrequest() {
  _oneof_case_[0] = kPNATRequest;
}
inline void Message::clear_pnatrequest() {
  if (has_pnatrequest()) {
    delete payload_.pnatrequest_;
    clear_has_payload();
  }
}
inline ::botnet_p2p::Message_NATRequest* Message::release_pnatrequest() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.pNATRequest)
  if (has_pnatrequest()) {
    clear_has_payload();
      ::botnet_p2p::Message_NATRequest* temp = payload_.pnatrequest_;
    payload_.pnatrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::botnet_p2p::Message_NATRequest& Message::pnatrequest() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.pNATRequest)
  return has_pnatrequest()
      ? *payload_.pnatrequest_
      : *reinterpret_cast< ::botnet_p2p::Message_NATRequest*>(&::botnet_p2p::_Message_NATRequest_default_instance_);
}
inline ::botnet_p2p::Message_NATRequest* Message::mutable_pnatrequest() {
  if (!has_pnatrequest()) {
    clear_payload();
    set_has_pnatrequest();
    payload_.pnatrequest_ = new ::botnet_p2p::Message_NATRequest;
  }
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.pNATRequest)
  return payload_.pnatrequest_;
}

// .botnet_p2p.Message.NATCheck pNATCheck = 11;
inline bool Message::has_pnatcheck() const {
  return payload_case() == kPNATCheck;
}
inline void Message::set_has_pnatcheck() {
  _oneof_case_[0] = kPNATCheck;
}
inline void Message::clear_pnatcheck() {
  if (has_pnatcheck()) {
    delete payload_.pnatcheck_;
    clear_has_payload();
  }
}
inline ::botnet_p2p::Message_NATCheck* Message::release_pnatcheck() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.pNATCheck)
  if (has_pnatcheck()) {
    clear_has_payload();
      ::botnet_p2p::Message_NATCheck* temp = payload_.pnatcheck_;
    payload_.pnatcheck_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::botnet_p2p::Message_NATCheck& Message::pnatcheck() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.pNATCheck)
  return has_pnatcheck()
      ? *payload_.pnatcheck_
      : *reinterpret_cast< ::botnet_p2p::Message_NATCheck*>(&::botnet_p2p::_Message_NATCheck_default_instance_);
}
inline ::botnet_p2p::Message_NATCheck* Message::mutable_pnatcheck() {
  if (!has_pnatcheck()) {
    clear_payload();
    set_has_pnatcheck();
    payload_.pnatcheck_ = new ::botnet_p2p::Message_NATCheck;
  }
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.pNATCheck)
  return payload_.pnatcheck_;
}

// .botnet_p2p.Message.Join pJoin = 12;
inline bool Message::has_pjoin() const {
  return payload_case() == kPJoin;
}
inline void Message::set_has_pjoin() {
  _oneof_case_[0] = kPJoin;
}
inline void Message::clear_pjoin() {
  if (has_pjoin()) {
    delete payload_.pjoin_;
    clear_has_payload();
  }
}
inline ::botnet_p2p::Message_Join* Message::release_pjoin() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.pJoin)
  if (has_pjoin()) {
    clear_has_payload();
      ::botnet_p2p::Message_Join* temp = payload_.pjoin_;
    payload_.pjoin_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::botnet_p2p::Message_Join& Message::pjoin() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.pJoin)
  return has_pjoin()
      ? *payload_.pjoin_
      : *reinterpret_cast< ::botnet_p2p::Message_Join*>(&::botnet_p2p::_Message_Join_default_instance_);
}
inline ::botnet_p2p::Message_Join* Message::mutable_pjoin() {
  if (!has_pjoin()) {
    clear_payload();
    set_has_pjoin();
    payload_.pjoin_ = new ::botnet_p2p::Message_Join;
  }
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.pJoin)
  return payload_.pjoin_;
}

// .botnet_p2p.Message.Leave pLeave = 13;
inline bool Message::has_pleave() const {
  return payload_case() == kPLeave;
}
inline void Message::set_has_pleave() {
  _oneof_case_[0] = kPLeave;
}
inline void Message::clear_pleave() {
  if (has_pleave()) {
    delete payload_.pleave_;
    clear_has_payload();
  }
}
inline ::botnet_p2p::Message_Leave* Message::release_pleave() {
  // @@protoc_insertion_point(field_release:botnet_p2p.Message.pLeave)
  if (has_pleave()) {
    clear_has_payload();
      ::botnet_p2p::Message_Leave* temp = payload_.pleave_;
    payload_.pleave_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::botnet_p2p::Message_Leave& Message::pleave() const {
  // @@protoc_insertion_point(field_get:botnet_p2p.Message.pLeave)
  return has_pleave()
      ? *payload_.pleave_
      : *reinterpret_cast< ::botnet_p2p::Message_Leave*>(&::botnet_p2p::_Message_Leave_default_instance_);
}
inline ::botnet_p2p::Message_Leave* Message::mutable_pleave() {
  if (!has_pleave()) {
    clear_payload();
    set_has_pleave();
    payload_.pleave_ = new ::botnet_p2p::Message_Leave;
  }
  // @@protoc_insertion_point(field_mutable:botnet_p2p.Message.pLeave)
  return payload_.pleave_;
}

inline bool Message::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Message::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Message::PayloadCase Message::payload_case() const {
  return Message::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace botnet_p2p

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::botnet_p2p::Message_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::botnet_p2p::Message_MessageType>() {
  return ::botnet_p2p::Message_MessageType_descriptor();
}
template <> struct is_proto_enum< ::botnet_p2p::Message_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::botnet_p2p::Message_Status>() {
  return ::botnet_p2p::Message_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
